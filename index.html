<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Master V12: Overload</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* 视频层 */
        #videoElement { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; opacity: 0; z-index: -1; pointer-events: none; transform: scaleX(-1); 
        }
        
        /* UI 层 */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; 
            pointer-events: none; 
        }
        
        /* 启动按钮 */
        #start-btn {
            pointer-events: auto; padding: 20px 80px; font-size: 32px; font-weight: 900; letter-spacing: 5px;
            color: #fff; background: rgba(0,0,0,0.8); 
            border: 4px solid #00ff88; border-radius: 2px; cursor: pointer;
            box-shadow: 0 0 30px #00ff88; text-shadow: 0 0 20px #00ff88; 
            transform: skewX(-10deg); transition: 0.1s;
        }
        #start-btn:hover { background: #00ff88; color: #000; box-shadow: 0 0 80px #00ff88; transform: skewX(-10deg) scale(1.05); }

        /* HUD */
        #hud { 
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; 
            display: none;
        }
        #spell-name {
            font-size: 48px; font-weight: 900; font-style: italic; letter-spacing: 2px;
            text-shadow: 0 0 30px currentColor; transition: transform 0.1s;
        }
        #score { font-size: 24px; color: #888; margin-top: 5px; font-family: monospace; }
        
        /* 蓄力条 */
        #charge-bar-container {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            width: 200px; height: 10px; background: rgba(0,0,0,0.5); border: 1px solid #444; display: none;
        }
        #charge-bar {
            width: 0%; height: 100%; background: #ff4500; 
            box-shadow: 0 0 20px #ff4500; transition: width 0.05s;
        }

        /* 准星 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            transform: translate(-50%, -50%); 
            border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; 
            pointer-events: none; z-index: 50; transition: 0.05s;
        }
        #crosshair.hit { border-color: #ff0055; transform: translate(-50%, -50%) scale(1.5); background: rgba(255,0,85,0.2); }
    </style>
</head>
<body>

<div id="hud">
    <div id="spell-name" style="color: #444;">SYSTEM READY</div>
    <div id="score">TARGETS DESTROYED: <span id="score-val" style="color:#fff">0</span></div>
</div>
<div id="charge-bar-container"><div id="charge-bar"></div></div>
<div id="crosshair"></div>

<div id="ui-layer">
    <h1 style="color:white; text-shadow: 0 0 40px #00ff88; margin-bottom: 50px; font-style:italic; font-size: 60px;">MAGIC V12</h1>
    <button id="start-btn" onclick="startApp()">OVERLOAD</button>
</div>

<video id="videoElement" playsinline muted autoplay></video>
<div id="canvas-container"></div>

<script type="importmap">
    { "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
    }}
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- 全局变量 ---
    let camera, scene, renderer, composer;
    let handLandmarker, video;
    let isRunning = false;
    
    // --- 游戏状态 ---
    const GameState = {
        projectiles: [],
        particles: [],
        targets: [],
        lightnings: [],
        beam: null,
        charging: { active: false, power: 0, mesh: null },
        score: 0,
        shake: 0, 
        cameraBasePos: new THREE.Vector3(0, 0, 25)
    };

    // --- 1. 图形引擎 ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.003); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.copy(GameState.cameraBasePos);

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // BLOOM 增强
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 3.0; 
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.05; 

        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        initAssets();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- 2. 资源 ---
    function initAssets() {
        const chargeGeo = new THREE.SphereGeometry(1, 32, 32);
        const chargeMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.9 });
        GameState.charging.mesh = new THREE.Mesh(chargeGeo, chargeMat);
        GameState.charging.mesh.add(new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({ color: 0xffffff })));
        GameState.charging.mesh.visible = false;
        scene.add(GameState.charging.mesh);

        const beamGeo = new THREE.CylinderGeometry(0.5, 2.0, 60, 8);
        beamGeo.rotateX(-Math.PI / 2);
        beamGeo.translate(0, 0, -30);
        const beamMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        GameState.beam = new THREE.Mesh(beamGeo, beamMat);
        GameState.beam.visible = false;
        scene.add(GameState.beam);
    }

    function spawnTarget() {
        if(GameState.targets.length > 5) return;
        const geo = new THREE.IcosahedronGeometry(Math.random()*1.5 + 1.5, 0);
        const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(Math.random(), 1, 0.5), wireframe: true, transparent:true, opacity: 0.5 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set((Math.random()-0.5) * 30, (Math.random()-0.5) * 15, -20 - Math.random() * 30);
        mesh.add(new THREE.Mesh(new THREE.IcosahedronGeometry(0.5), new THREE.MeshBasicMaterial({color:0xffffff})));
        scene.add(mesh);
        GameState.targets.push({ mesh: mesh, rotSpeed: (Math.random()-0.5)*0.1 });
    }

    // --- 3. 特效系统 ---
    function getGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.3, 'rgba(255,255,255,0.8)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        return new THREE.CanvasTexture(canvas);
    }
    const particleTex = getGlowTexture();

    function triggerShake(intensity) { GameState.shake = intensity; }

    function createExplosion(pos, color, scale=1.0) {
        const count = 30 * scale;
        for(let i=0; i<count; i++) {
            const size = (Math.random()*0.5 + 0.2) * scale;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: particleTex, color: color, blending: THREE.AdditiveBlending }));
            sprite.position.copy(pos);
            sprite.scale.set(size, size, 1);
            const vel = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar((Math.random()*0.5+0.2)*scale);
            scene.add(sprite);
            GameState.particles.push({ mesh: sprite, vel: vel, life: 40 + Math.random()*20, drag: 0.95 });
        }
        triggerShake(0.5 * scale);
        const ch = document.getElementById('crosshair');
        ch.classList.add('hit'); setTimeout(()=>ch.classList.remove('hit'), 100);
    }

    function shootProjectile(pos, type) {
        let color, size, speed, life, scale=1;
        
        if (type === 'missile') { 
            color = 0x00ffff; size = 0.8; speed = 2.5; life = 80;
        } else if (type === 'nuke') { 
            color = 0xff3300; size = 4.0 + (GameState.charging.power/8); speed = 1.5; life = 120; scale=3;
        }

        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: particleTex, color: color, blending: THREE.AdditiveBlending }));
        sprite.position.copy(pos);
        sprite.scale.set(size, size, 1);

        const target = new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, -100);
        const velocity = new THREE.Vector3().subVectors(target, pos).normalize().multiplyScalar(speed);

        scene.add(sprite);
        GameState.projectiles.push({ mesh: sprite, vel: velocity, type: type, life: life, scale: scale });
    }

    function castLightning(start) {
        const points = []; let curr = start.clone();
        let target = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, -30);
        if(GameState.targets.length > 0) {
            target = GameState.targets[0].mesh.position.clone();
            createExplosion(target, 0xaa00ff, 0.5); 
            scene.remove(GameState.targets[0].mesh); GameState.targets.shift();
            GameState.score++;
        }
        for(let i=0; i<8; i++) {
            points.push(curr.clone());
            curr.lerp(target, 0.2).add(new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, 0));
        }
        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0xaa00ff, linewidth: 3 }));
        scene.add(line);
        GameState.lightnings.push({ mesh: line, life: 6 }); // 生命设为 6 帧
        triggerShake(0.2);
    }

    // --- 4. 逻辑 ---
    function updateLogic(landmarks) {
        const lm = landmarks;
        const palm = screenToWorld(lm[9].x, lm[9].y, 0);
        const idxTip = screenToWorld(lm[8].x, lm[8].y, 0);
        const idxUp = lm[8].y < lm[6].y;
        const midUp = lm[12].y < lm[10].y;
        const ringUp = lm[16].y < lm[14].y;
        const pinkyUp = lm[20].y < lm[18].y;
        const isPinching = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.05;

        const hudName = document.getElementById('spell-name');
        
        // 1. NUKE
        if (isPinching) {
            GameState.charging.active = true;
            GameState.charging.power = Math.min(GameState.charging.power + 2, 100);
            GameState.charging.mesh.visible = true;
            GameState.charging.mesh.position.copy(idxTip);
            const scale = 0.5 + (GameState.charging.power / 20);
            GameState.charging.mesh.scale.set(scale, scale, scale);
            GameState.charging.mesh.position.add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, 0));
            hudName.innerText = "CHARGING NUKE"; hudName.style.color = "#ff3300";
            document.getElementById('charge-bar-container').style.display = 'block';
            document.getElementById('charge-bar').style.width = GameState.charging.power + '%';
            triggerShake(GameState.charging.power / 500);
            return;
        } 
        
        if (GameState.charging.active && !isPinching) {
            if (GameState.charging.power > 15) shootProjectile(idxTip, 'nuke');
            GameState.charging.active = false; GameState.charging.power = 0; GameState.charging.mesh.visible = false;
            document.getElementById('charge-bar-container').style.display = 'none';
        }

        // 2. AUTO BARRAGE (粒子翻倍版)
        if (idxUp && midUp && ringUp && pinkyUp) {
            hudName.innerText = "RAPID FIRE"; hudName.style.color = "#00ff88";
            // 提高发射频率
            if (performance.now() % 100 < 50) { 
                // !!! 关键修改：一次发射 3 发 !!!
                for(let i=0; i<3; i++) {
                    const offset = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, 0);
                    shootProjectile(palm.clone().add(offset), 'missile');
                }
            }
        }
        
        // 3. THUNDER
        else if (idxUp && pinkyUp && !midUp && !ringUp) {
            hudName.innerText = "THUNDER STORM"; hudName.style.color = "#aa00ff";
            if(Math.random() > 0.6) castLightning(idxTip);
        }

        // 4. BEAM
        else if (idxUp && midUp && !ringUp && !pinkyUp) {
            hudName.innerText = "DEATH BEAM"; hudName.style.color = "#ff00ff";
            GameState.beam.visible = true;
            const mid = screenToWorld(lm[12].x, lm[12].y, 0);
            GameState.beam.position.copy(idxTip).add(mid).multiplyScalar(0.5);
            
            GameState.targets.forEach((t, i) => {
                if (Math.abs(t.mesh.position.x - GameState.beam.position.x) < 3) {
                    createExplosion(t.mesh.position, 0xff00ff, 0.8);
                    scene.remove(t.mesh); GameState.targets.splice(i, 1); GameState.score++; triggerShake(0.3);
                }
            });
        } else {
            GameState.beam.visible = false;
            if(!isPinching && !idxUp) hudName.innerText = "READY";
        }
    }

    function animate() {
        if (!isRunning) return;
        requestAnimationFrame(animate);

        // Shake
        if (GameState.shake > 0) {
            camera.position.x = GameState.cameraBasePos.x + (Math.random()-0.5) * GameState.shake;
            camera.position.y = GameState.cameraBasePos.y + (Math.random()-0.5) * GameState.shake;
            camera.position.z = GameState.cameraBasePos.z + (Math.random()-0.5) * GameState.shake;
            GameState.shake *= 0.9; 
            if(GameState.shake < 0.01) GameState.shake = 0;
        } else { camera.position.copy(GameState.cameraBasePos); }

        // Targets
        if(Math.random() > 0.98) spawnTarget();
        GameState.targets.forEach((t, i) => {
            t.mesh.rotation.x += t.rotSpeed; t.mesh.rotation.y += t.rotSpeed;
            t.mesh.position.z += 0.05; 
            if(t.mesh.position.z > 5) { scene.remove(t.mesh); GameState.targets.splice(i, 1); }
        });

        // Projectiles
        for (let i = GameState.projectiles.length - 1; i >= 0; i--) {
            const p = GameState.projectiles[i];
            p.mesh.position.add(p.vel);
            p.life--;
            let hit = false;
            for(let j = GameState.targets.length - 1; j >= 0; j--) {
                const t = GameState.targets[j];
                if (p.mesh.position.distanceTo(t.mesh.position) < 3.0) {
                    createExplosion(t.mesh.position, p.mesh.material.color, p.scale);
                    scene.remove(t.mesh); GameState.targets.splice(j, 1); GameState.score += (p.type==='nuke'?5:1); hit = true; break;
                }
            }
            if (hit || p.life <= 0 || p.mesh.position.z < -150) { scene.remove(p.mesh); GameState.projectiles.splice(i, 1); }
        }
        document.getElementById('score-val').innerText = GameState.score;

        // !!! 关键修复：闪电生命周期清理 !!!
        for (let i = GameState.lightnings.length - 1; i >= 0; i--) {
            const l = GameState.lightnings[i];
            l.life--;
            l.mesh.material.opacity = l.life / 6; // 渐隐
            if (l.life <= 0) {
                scene.remove(l.mesh);
                GameState.lightnings.splice(i, 1);
            }
        }

        // Particles
        for (let i = GameState.particles.length - 1; i >= 0; i--) {
            const p = GameState.particles[i];
            p.mesh.position.add(p.vel); p.vel.multiplyScalar(p.drag);
            p.life--; p.mesh.scale.multiplyScalar(0.92);
            if (p.life <= 0) { scene.remove(p.mesh); GameState.particles.splice(i, 1); }
        }

        const now = performance.now();
        if (handLandmarker && video.currentTime > 0) {
            const results = handLandmarker.detectForVideo(video, now);
            if (results.landmarks && results.landmarks.length > 0) updateLogic(results.landmarks[0]);
            else { GameState.beam.visible = false; GameState.charging.mesh.visible = false; document.getElementById('charge-bar-container').style.display='none';}
        }

        composer.render();
    }

    function screenToWorld(x, y, z) {
        const vec = new THREE.Vector3(((1-x)*2)-1, -(y*2)+1, 0.5);
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        return camera.position.clone().add(vec.multiplyScalar(-camera.position.z/vec.z + z));
    }

    window.startApp = async function() {
        const btn = document.getElementById('start-btn'); btn.innerText = "LOADING...";
        initThree();
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        video = document.getElementById('videoElement');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
        video.srcObject = stream;
        video.onloadeddata = () => {
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            isRunning = true;
            animate();
        };
    }
</script>
</body>
</html>
