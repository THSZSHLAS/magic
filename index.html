<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Void Arcana: Elemental Interface</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #videoElement { display: none; } /* éšè—åŸå§‹è§†é¢‘ï¼Œæˆ‘ä»¬åªçœ‹ç‰¹æ•ˆ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 2;
            color: rgba(255, 255, 255, 0.7); font-family: 'Courier New', monospace;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>VOID ARCANA SYSTEM</h1>
    <p>Status: <span id="status">Connecting...</span></p>
    <p>Instructions:</p>
    <ul>
        <li>Draw â–² (Triangle) -> Fireball</li>
        <li>Draw â–  (Square) -> Explosion</li>
        <li>Draw â— (Circle) -> Ice Shards</li>
        <li>Hold ğŸ‘Œ (OK Sign) -> Void Charge</li>
    </ul>
</div>

<video id="videoElement" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- 1. åˆå§‹åŒ– æ‘„åƒå¤´ & WebSocket ---
    const video = document.getElementById('videoElement');
    const statusText = document.getElementById('status');
    const ws = new WebSocket(`ws://${location.host}/ws`);
    
    // ç¦»å± Canvas ç”¨äºå‹ç¼©å›¾ç‰‡å‘é€ç»™åç«¯
    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');

    navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false })
        .then(stream => {
            video.srcObject = stream;
            video.play();
            statusText.innerText = "Camera Active. Syncing...";
        })
        .catch(err => console.error("Camera Error:", err));

    ws.onopen = () => { statusText.innerText = "System Online. Awaiting Input."; };
    
    // --- 2. Three.js åœºæ™¯è®¾ç½® (é­”æ³•ä¸–ç•Œ) ---
    const scene = new THREE.Scene();
    // æ·»åŠ ä¸€ç‚¹ç¯å¢ƒé›¾æ°”
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 500;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // å­˜å‚¨æ‰€æœ‰çš„é­”æ³•ç‰©ä½“
    const spells = [];
    const particles = [];

    // --- 3. é­”æ³•å·¥å‚ (Visual Effects) ---

    // åˆ›å»ºç«çƒ
    function createFireball(x, y, isBig) {
        const geometry = new THREE.SphereGeometry(isBig ? 30 : 15, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xff4500 });
        const sphere = new THREE.Mesh(geometry, material);
        
        // è½¬æ¢ 2D åæ ‡åˆ° 3D ç©ºé—´ (ç®€åŒ–ç‰ˆæ˜ å°„)
        sphere.position.x = (x / 640) * window.innerWidth - window.innerWidth / 2;
        sphere.position.y = -((y / 480) * window.innerHeight - window.innerHeight / 2);
        sphere.position.z = 0;
        
        scene.add(sphere);
        spells.push({ mesh: sphere, type: 'fire', velocity: new THREE.Vector3(0, 0, -10) });
    }

    // åˆ›å»ºå†°é”¥
    function createIceShard(x, y) {
        const geometry = new THREE.ConeGeometry(5, 30, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const cone = new THREE.Mesh(geometry, material);
        
        cone.position.x = (x / 640) * window.innerWidth - window.innerWidth / 2;
        cone.position.y = -((y / 480) * window.innerHeight - window.innerHeight / 2);
        cone.rotation.x = -Math.PI / 2; // æŒ‡å‘å±å¹•å†…
        
        scene.add(cone);
        spells.push({ mesh: cone, type: 'ice', velocity: new THREE.Vector3(0, 0, -15) });
    }

    // è™šç©ºå……èƒ½ç‰¹æ•ˆ (ç²’å­)
    function createVoidParticles(x, y) {
        // ç®€å•æ¨¡æ‹Ÿï¼šåœ¨æŒ‡å°–ä½ç½®ç”Ÿæˆéšæœºç´«è‰²ç²’å­
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        vertices.push(0,0,0);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        
        const material = new THREE.PointsMaterial({ color: 0x8a2be2, size: 10 });
        const point = new THREE.Points(geometry, material);
        
        point.position.x = (x / 640) * window.innerWidth - window.innerWidth / 2;
        point.position.y = -((y / 480) * window.innerHeight - window.innerHeight / 2);
        point.position.z = 50;

        scene.add(point);
        particles.push({ mesh: point, life: 20 }); // å¯¿å‘½ 20 å¸§
    }
    
    // ç»˜åˆ¶è½¨è¿¹ (Drawing Trail)
    let trailPoints = [];
    const trailMaterial = new THREE.LineBasicMaterial({ color: 0xffd700 }); // é‡‘è‰²è½¨è¿¹
    let trailLine = null;

    function updateTrail(x, y) {
        const vec = new THREE.Vector3(
            (x / 640) * window.innerWidth - window.innerWidth / 2,
            -((y / 480) * window.innerHeight - window.innerHeight / 2),
            100
        );
        trailPoints.push(vec);
        if(trailPoints.length > 50) trailPoints.shift(); // é™åˆ¶è½¨è¿¹é•¿åº¦

        if(trailLine) scene.remove(trailLine);
        const geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
        trailLine = new THREE.Line(geometry, trailMaterial);
        scene.add(trailLine);
    }

    // --- 4. ä¸»å¾ªç¯ ---
    
    // å¤„ç†åç«¯è¿”å›çš„æ¶ˆæ¯
    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        
        if (data.type === "drawing") {
            updateTrail(data.x, data.y);
        } else if (data.type === "void_charge") {
            createVoidParticles(data.x, data.y);
            trailPoints = []; // æ¸…ç©ºè½¨è¿¹
            if(trailLine) scene.remove(trailLine);
        } else if (data.type === "cast_spell") {
            // æ–½æ³•ï¼
            trailPoints = []; // æ¸…ç©ºè½¨è¿¹
            if(trailLine) scene.remove(trailLine);
            
            if (data.spell === "triangle") createFireball(data.x, data.y, false);
            if (data.spell === "square") createFireball(data.x, data.y, true);
            if (data.spell === "circle") createIceShard(data.x, data.y);
        }
    };

    // åŠ¨ç”»å¾ªç¯
    function animate() {
        requestAnimationFrame(animate);

        // 1. å‘é€è§†é¢‘å¸§ç»™ Python (é™åˆ¶é¢‘ç‡ä»¥é˜²å¡é¡¿ï¼Œè¿™é‡Œæ¯éš” 3 å¸§å‘ä¸€æ¬¡)
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            offCanvas.width = 640; // å‹ç¼©åˆ†è¾¨ç‡
            offCanvas.height = 480;
            offCtx.drawImage(video, 0, 0, 640, 480);
            // åªæœ‰å½“ WS è¿æ¥æ‰“å¼€æ—¶æ‰å‘é€
            if(ws.readyState === WebSocket.OPEN) {
               // å®é™…é¡¹ç›®ä¸­è¿™é‡Œéœ€è¦èŠ‚æµ (Throttle)
               const imageData = offCanvas.toDataURL('image/jpeg', 0.5);
               ws.send(imageData); 
            }
        }

        // 2. æ›´æ–°é­”æ³•ç‰©ä½“ä½ç½®
        for (let i = spells.length - 1; i >= 0; i--) {
            const s = spells[i];
            s.mesh.position.add(s.velocity);
            
            // ç®€å•çš„æ—‹è½¬æ•ˆæœ
            s.mesh.rotation.z += 0.1;
            if(s.type === 'fire') s.mesh.rotation.x += 0.1;

            // é£å¤ªè¿œå°±é”€æ¯
            if (s.mesh.position.z < -1000) {
                scene.remove(s.mesh);
                spells.splice(i, 1);
            }
        }

        // 3. æ›´æ–°ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life--;
            p.mesh.material.opacity = p.life / 20;
            if (p.life <= 0) {
                scene.remove(p.mesh);
                particles.splice(i, 1);
            }
        }

        renderer.render(scene, camera);
    }
    animate();

    // çª—å£å¤§å°è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
