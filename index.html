<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Master V11: Impact</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* 视频层 */
        #videoElement { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; opacity: 0; z-index: -1; pointer-events: none; transform: scaleX(-1); 
        }
        
        /* UI 层 */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; 
            pointer-events: none; 
        }
        
        /* 启动按钮 */
        #start-btn {
            pointer-events: auto; padding: 20px 80px; font-size: 32px; font-weight: 900; letter-spacing: 5px;
            color: #fff; background: rgba(0,0,0,0.8); 
            border: 4px solid #ff0055; border-radius: 2px; cursor: pointer;
            box-shadow: 0 0 30px #ff0055; text-shadow: 0 0 20px #ff0055; 
            transform: skewX(-10deg); transition: 0.1s;
        }
        #start-btn:hover { background: #ff0055; color: #000; box-shadow: 0 0 80px #ff0055; transform: skewX(-10deg) scale(1.05); }

        /* HUD */
        #hud { 
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; 
            display: none;
        }
        #spell-name {
            font-size: 48px; font-weight: 900; font-style: italic; letter-spacing: 2px;
            text-shadow: 0 0 30px currentColor; transition: transform 0.1s;
        }
        #score { font-size: 24px; color: #888; margin-top: 5px; font-family: monospace; }
        
        /* 蓄力条 (更暴力) */
        #charge-bar-container {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            width: 200px; height: 10px; background: rgba(0,0,0,0.5); border: 1px solid #444; display: none;
        }
        #charge-bar {
            width: 0%; height: 100%; background: #ff4500; 
            box-shadow: 0 0 20px #ff4500; transition: width 0.05s;
        }

        /* 准星 (动态反馈) */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            transform: translate(-50%, -50%); 
            border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%; 
            pointer-events: none; z-index: 50; transition: 0.05s;
        }
        #crosshair.hit { border-color: #ff0055; transform: translate(-50%, -50%) scale(1.5); background: rgba(255,0,85,0.2); }
    </style>
</head>
<body>

<div id="hud">
    <div id="spell-name" style="color: #444;">SYSTEM READY</div>
    <div id="score">TARGETS DESTROYED: <span id="score-val" style="color:#fff">0</span></div>
</div>
<div id="charge-bar-container"><div id="charge-bar"></div></div>
<div id="crosshair"></div>

<div id="ui-layer">
    <h1 style="color:white; text-shadow: 0 0 40px #ff0055; margin-bottom: 50px; font-style:italic; font-size: 60px;">MAGIC V11</h1>
    <button id="start-btn" onclick="startApp()">DOMINATE</button>
</div>

<video id="videoElement" playsinline muted autoplay></video>
<div id="canvas-container"></div>

<script type="importmap">
    { "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
    }}
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- 全局变量 ---
    let camera, scene, renderer, composer;
    let handLandmarker, video;
    let isRunning = false;
    
    // --- 游戏状态 ---
    const GameState = {
        projectiles: [],
        particles: [],
        targets: [], // 靶子
        lightnings: [],
        beam: null,
        charging: { active: false, power: 0, mesh: null },
        score: 0,
        shake: 0, // 屏幕震动强度
        cameraBasePos: new THREE.Vector3(0, 0, 25)
    };

    // --- 1. 图形引擎 (Visuals Overdrive) ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.003); 

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.copy(GameState.cameraBasePos);

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false }); // Post-proc handles AA
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- OVERDRIVE BLOOM (过饱和光效) ---
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 3.5; // 强度翻倍 (原1.5)
        bloomPass.radius = 0.6;
        bloomPass.threshold = 0.05; // 即使是暗光也发光

        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        initAssets();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- 2. 资源与靶子 (Assets & Targets) ---
    function initAssets() {
        // 蓄力球 (多层结构，看起来更亮)
        const chargeGeo = new THREE.SphereGeometry(1, 32, 32);
        const chargeMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.9 });
        GameState.charging.mesh = new THREE.Mesh(chargeGeo, chargeMat);
        // 添加核心白光
        const coreGeo = new THREE.SphereGeometry(0.6, 16, 16);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        GameState.charging.mesh.add(new THREE.Mesh(coreGeo, coreMat));
        
        GameState.charging.mesh.visible = false;
        scene.add(GameState.charging.mesh);

        // 激光
        const beamGeo = new THREE.CylinderGeometry(0.5, 2.0, 60, 8);
        beamGeo.rotateX(-Math.PI / 2);
        beamGeo.translate(0, 0, -30);
        const beamMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        GameState.beam = new THREE.Mesh(beamGeo, beamMat);
        GameState.beam.visible = false;
        scene.add(GameState.beam);
    }

    function spawnTarget() {
        if(GameState.targets.length > 5) return; // 限制数量

        // 生成漂浮的能量立方体
        const geo = new THREE.IcosahedronGeometry(Math.random()*1.5 + 1.5, 0);
        const mat = new THREE.MeshBasicMaterial({ 
            color: new THREE.Color().setHSL(Math.random(), 1, 0.5), 
            wireframe: true, transparent:true, opacity: 0.5 
        });
        const mesh = new THREE.Mesh(geo, mat);
        
        // 随机位置 (屏幕前方)
        mesh.position.set(
            (Math.random()-0.5) * 30,
            (Math.random()-0.5) * 15,
            -20 - Math.random() * 30
        );
        
        // 内部发光体
        const inner = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 0), new THREE.MeshBasicMaterial({color:0xffffff}));
        mesh.add(inner);

        scene.add(mesh);
        GameState.targets.push({ mesh: mesh, rotSpeed: (Math.random()-0.5)*0.1 });
    }

    // --- 3. 增强型特效 (Impact FX) ---
    
    // 生成光晕贴图
    function getGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.3, 'rgba(255,255,255,0.8)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        return new THREE.CanvasTexture(canvas);
    }
    const particleTex = getGlowTexture();

    // 屏幕震动
    function triggerShake(intensity) {
        GameState.shake = intensity;
    }

    // 爆炸 (大量粒子喷射)
    function createExplosion(pos, color, scale=1.0) {
        const count = 30 * scale; // 粒子数量增加
        for(let i=0; i<count; i++) {
            const size = (Math.random()*0.5 + 0.2) * scale;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                map: particleTex, color: color, blending: THREE.AdditiveBlending 
            }));
            sprite.position.copy(pos);
            sprite.scale.set(size, size, 1);
            
            // 爆发速度
            const speed = (Math.random() * 0.5 + 0.2) * scale;
            const vel = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar(speed);
            
            scene.add(sprite);
            GameState.particles.push({ mesh: sprite, vel: vel, life: 40 + Math.random()*20, drag: 0.95 });
        }
        
        // 震动屏幕
        triggerShake(0.5 * scale);
        
        // 准星反馈
        const ch = document.getElementById('crosshair');
        ch.classList.add('hit');
        setTimeout(()=>ch.classList.remove('hit'), 100);
    }

    function shootProjectile(pos, type) {
        let color, size, speed, life, scale=1;
        
        if (type === 'missile') { 
            color = 0x00ffff; size = 1.0; speed = 3.0; life = 80;
        } else if (type === 'nuke') { 
            color = 0xff3300; size = 4.0 + (GameState.charging.power/8); speed = 1.5; life = 120; scale=3;
        }

        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: particleTex, color: color, blending: THREE.AdditiveBlending }));
        sprite.position.copy(pos);
        sprite.scale.set(size, size, 1);

        const target = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, -100);
        const velocity = new THREE.Vector3().subVectors(target, pos).normalize().multiplyScalar(speed);

        scene.add(sprite);
        GameState.projectiles.push({ mesh: sprite, vel: velocity, type: type, life: life, scale: scale });
    }

    // 闪电链 (更粗更亮)
    function castLightning(start) {
        const points = [];
        let curr = start.clone();
        // 寻找最近的靶子作为目标，如果没有就随机
        let target = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, -30);
        if(GameState.targets.length > 0) {
            target = GameState.targets[0].mesh.position.clone();
            createExplosion(target, 0xaa00ff, 0.5); // 击中反馈
            scene.remove(GameState.targets[0].mesh);
            GameState.targets.shift();
            GameState.score++;
            document.getElementById('score-val').innerText = GameState.score;
        }

        for(let i=0; i<8; i++) {
            points.push(curr.clone());
            curr.lerp(target, 0.2).add(new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, 0));
        }
        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0xaa00ff, linewidth: 3 }));
        scene.add(line);
        GameState.lightnings.push({ mesh: line, life: 4 });
        triggerShake(0.2);
    }

    // --- 4. 逻辑主循环 ---
    function updateLogic(landmarks) {
        const lm = landmarks;
        const palm = screenToWorld(lm[9].x, lm[9].y, 0);
        const idxTip = screenToWorld(lm[8].x, lm[8].y, 0);
        const idxUp = lm[8].y < lm[6].y;
        const midUp = lm[12].y < lm[10].y;
        const ringUp = lm[16].y < lm[14].y;
        const pinkyUp = lm[20].y < lm[18].y;
        const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
        const isPinching = pinchDist < 0.05;

        const hudName = document.getElementById('spell-name');
        const chargeCont = document.getElementById('charge-bar-container');
        
        // 1. 蓄力核弹 (NUKE)
        if (isPinching) {
            GameState.charging.active = true;
            GameState.charging.power = Math.min(GameState.charging.power + 2, 100); // 蓄力更快
            
            GameState.charging.mesh.visible = true;
            GameState.charging.mesh.position.copy(idxTip);
            const scale = 0.5 + (GameState.charging.power / 20);
            GameState.charging.mesh.scale.set(scale, scale, scale);
            // 剧烈抖动蓄力球
            GameState.charging.mesh.position.add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, 0));
            
            hudName.innerText = "CHARGING NUKE"; hudName.style.color = "#ff3300";
            chargeCont.style.display = 'block';
            document.getElementById('charge-bar').style.width = GameState.charging.power + '%';
            triggerShake(GameState.charging.power / 500); // 蓄力时屏幕微震
            return;
        } 
        
        if (GameState.charging.active && !isPinching) {
            if (GameState.charging.power > 15) shootProjectile(idxTip, 'nuke');
            GameState.charging.active = false; GameState.charging.power = 0; GameState.charging.mesh.visible = false;
            chargeCont.style.display = 'none';
        }

        // 2. 速射 (AUTO FIRE)
        if (idxUp && midUp && ringUp && pinkyUp) {
            hudName.innerText = "RAPID FIRE"; hudName.style.color = "#00ffff";
            if (performance.now() % 100 < 30) shootProjectile(palm, 'missile');
        }
        
        // 3. 闪电 (THUNDER)
        else if (idxUp && pinkyUp && !midUp && !ringUp) {
            hudName.innerText = "THUNDER STORM"; hudName.style.color = "#aa00ff";
            if(Math.random() > 0.6) castLightning(idxTip);
        }

        // 4. 激光 (BEAM)
        else if (idxUp && midUp && !ringUp && !pinkyUp) {
            hudName.innerText = "DEATH BEAM"; hudName.style.color = "#ff00ff";
            GameState.beam.visible = true;
            const mid = screenToWorld(lm[12].x, lm[12].y, 0);
            GameState.beam.position.copy(idxTip).add(mid).multiplyScalar(0.5);
            
            // 激光碰撞检测
            GameState.targets.forEach((t, i) => {
                // 简单判断：激光位置和靶子X距离接近
                if (Math.abs(t.mesh.position.x - GameState.beam.position.x) < 3) {
                    createExplosion(t.mesh.position, 0xff00ff, 0.8);
                    scene.remove(t.mesh);
                    GameState.targets.splice(i, 1);
                    GameState.score++;
                    triggerShake(0.3);
                }
            });
        } else {
            GameState.beam.visible = false;
            if(!isPinching && !idxUp) hudName.innerText = "READY";
        }
    }

    function animate() {
        if (!isRunning) return;
        requestAnimationFrame(animate);

        // A. 摄像机震动处理
        if (GameState.shake > 0) {
            camera.position.x = GameState.cameraBasePos.x + (Math.random()-0.5) * GameState.shake;
            camera.position.y = GameState.cameraBasePos.y + (Math.random()-0.5) * GameState.shake;
            camera.position.z = GameState.cameraBasePos.z + (Math.random()-0.5) * GameState.shake;
            GameState.shake *= 0.9; // 衰减
            if(GameState.shake < 0.01) GameState.shake = 0;
        } else {
            camera.position.copy(GameState.cameraBasePos);
        }

        // B. 生成靶子
        if(Math.random() > 0.98) spawnTarget();
        GameState.targets.forEach((t, i) => {
            t.mesh.rotation.x += t.rotSpeed; t.mesh.rotation.y += t.rotSpeed;
            t.mesh.position.z += 0.05; // 慢慢飞近
            if(t.mesh.position.z > 5) { scene.remove(t.mesh); GameState.targets.splice(i, 1); } // 飞过头了
        });

        // C. 子弹与碰撞
        for (let i = GameState.projectiles.length - 1; i >= 0; i--) {
            const p = GameState.projectiles[i];
            p.mesh.position.add(p.vel);
            p.life--;
            
            // 碰撞检测
            let hit = false;
            for(let j = GameState.targets.length - 1; j >= 0; j--) {
                const t = GameState.targets[j];
                if (p.mesh.position.distanceTo(t.mesh.position) < 3.0) {
                    createExplosion(t.mesh.position, p.mesh.material.color, p.scale);
                    scene.remove(t.mesh);
                    GameState.targets.splice(j, 1);
                    GameState.score += (p.type==='nuke'?5:1);
                    hit = true;
                    break;
                }
            }

            if (hit || p.life <= 0 || p.mesh.position.z < -150) {
                scene.remove(p.mesh);
                GameState.projectiles.splice(i, 1);
            }
        }
        document.getElementById('score-val').innerText = GameState.score;

        // D. 粒子更新
        for (let i = GameState.particles.length - 1; i >= 0; i--) {
            const p = GameState.particles[i];
            p.mesh.position.add(p.vel);
            p.vel.multiplyScalar(p.drag); // 阻力
            p.life--;
            p.mesh.scale.multiplyScalar(0.92);
            if (p.life <= 0) { scene.remove(p.mesh); GameState.particles.splice(i, 1); }
        }

        const now = performance.now();
        if (handLandmarker && video.currentTime > 0) {
            const results = handLandmarker.detectForVideo(video, now);
            if (results.landmarks && results.landmarks.length > 0) updateLogic(results.landmarks[0]);
            else { GameState.beam.visible = false; GameState.charging.mesh.visible = false; document.getElementById('charge-bar-container').style.display='none';}
        }

        composer.render();
    }

    function screenToWorld(x, y, z) {
        const vec = new THREE.Vector3(((1-x)*2)-1, -(y*2)+1, 0.5);
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        return camera.position.clone().add(vec.multiplyScalar(-camera.position.z/vec.z + z));
    }

    window.startApp = async function() {
        const btn = document.getElementById('start-btn'); btn.innerText = "LOADING...";
        initThree();
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        video = document.getElementById('videoElement');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
        video.srcObject = stream;
        video.onloadeddata = () => {
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            isRunning = true;
            animate();
        };
    }
</script>
</body>
</html>
