<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è™šç©ºå¥¥æœ¯ï¼šå…ƒç´ å¤§å¸ˆ (Void Arcana Master)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: rgba(255, 255, 255, 0.9); 
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }
        
        /* å±å¹•æ—¥å¿— - ä¸“é—¨ç”¨æ¥åœ¨æ‰‹æœº/Macä¸Šçœ‹æŠ¥é”™ */
        #debug-console {
            position: absolute; bottom: 10px; left: 10px; width: 90%; 
            max-height: 150px; overflow-y: auto;
            color: #ff3333; background: rgba(0,0,0,0.5);
            font-size: 12px; pointer-events: none; z-index: 20;
            display: none; /* é»˜è®¤éšè—ï¼Œæœ‰é”™æ‰æ˜¾ç¤º */
        }

        .guide-box {
            background: rgba(0, 20, 40, 0.6);
            padding: 15px;
            border-left: 3px solid #00ffff;
            border-radius: 4px;
            margin-top: 10px;
        }
        .loading { color: #0ff; animation: blink 1s infinite; font-weight: bold; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>VOID ARCANA <span style="font-size:0.5em; color:#aaa">MASTER</span></h1>
    <div id="status" class="loading">æ­£åœ¨è¿æ¥é­”æ³•ç½‘ç»œ... (Init AI...)</div>
    
    <div id="instructions" class="guide-box" style="display:none;">
        <p>ğŸ–ï¸ <b>æ‰‹æŒå¼ å¼€</b>: å…‰æ£±æŠ¤ç›¾ (Shield)</p>
        <p>ğŸ¤˜ <b>æ‘‡æ»šæ‰‹åŠ¿</b>: é›·éœ†é”é“¾ (Lightning)</p>
        <p>âœŠ <b>ç”¨åŠ›æ¡æ‹³</b>: é»‘æ´å¼•åŠ› (Gravity)</p>
        <p>â˜ï¸ <b>é£ŸæŒ‡ç§»åŠ¨</b>: æµå…‰è½¨è¿¹ (Trace)</p>
    </div>
</div>

<div id="debug-console"></div>

<video id="videoElement" playsinline style="display:none"></video>
<div id="canvas-container"></div>

<script type="module">
    // 1. å¼•å…¥ Three.js (ä½¿ç”¨æ›´ç¨³å®šçš„ CDN)
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    // 2. å¼•å…¥ MediaPipe (Google å®˜æ–¹è§†è§‰åº“)
    import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm';

    // --- å±å¹•æ—¥å¿—ç³»ç»Ÿ (Debug System) ---
    const debugDiv = document.getElementById('debug-console');
    function logError(msg) {
        debugDiv.style.display = 'block';
        debugDiv.innerHTML += `> [ERROR] ${msg}<br>`;
        console.error(msg);
    }
    function logInfo(msg) {
        const status = document.getElementById('status');
        if(status) status.innerText = msg;
        console.log(msg);
    }

    // --- å…¨å±€å˜é‡ ---
    const video = document.getElementById('videoElement');
    let handLandmarker = undefined;
    let lastVideoTime = -1;
    let results = undefined;
    const w = window.innerWidth;
    const h = window.innerHeight;

    // --- Three.js åœºæ™¯è®¾ç½® ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002); 

    const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
    camera.position.z = 20;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(w, h);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 2); 
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(0, 10, 10);
    scene.add(dirLight);

    // --- é­”æ³•ç‰¹æ•ˆå¯¹è±¡æ±  ---
    const particles = []; 
    const lightningBolts = [];
    let shieldMesh = null;
    let trailMesh = null;
    const trailPoints = [];

    // --- æè´¨é¢„è®¾ ---
    // æŠ¤ç›¾æè´¨ (åŠé€æ˜å‘å…‰)
    const shieldMat = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, emissive: 0x0044aa, 
        transparent: true, opacity: 0.3, 
        side: THREE.DoubleSide, wireframe: true 
    });
    // é›·ç”µæè´¨
    const lightningMat = new THREE.LineBasicMaterial({ color: 0xaa00ff, linewidth: 3 });

    // --- è¾…åŠ©å‡½æ•°ï¼šåæ ‡è½¬æ¢ ---
    function screenToWorld(x, y, z = 10) {
        const vec = new THREE.Vector3();
        // MediaPipe x æ˜¯é•œåƒçš„ï¼Œæ‰€ä»¥è¿™é‡Œå¯èƒ½éœ€è¦æ ¹æ®æƒ…å†µåè½¬
        // é€šå¸¸ webcam æ˜¯é•œåƒçš„ï¼Œæ‰€ä»¥ x éœ€è¦ 1-x
        vec.set(((1-x) * 2) - 1, -(y * 2) + 1, 0.5); 
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        const distance = -camera.position.z / vec.z + z;
        return camera.position.clone().add(vec.multiplyScalar(distance));
    }

    // --- é­”æ³•å®ç° ---

    // 1. æŠ¤ç›¾é€»è¾‘ (Shield)
    function updateShield(handCenter, isActive) {
        if (!shieldMesh) {
            const geometry = new THREE.IcosahedronGeometry(4, 1);
            shieldMesh = new THREE.Mesh(geometry, shieldMat);
            scene.add(shieldMesh);
        }
        
        if (isActive) {
            const pos = screenToWorld(handCenter.x, handCenter.y, -5);
            shieldMesh.position.lerp(pos, 0.2); // å¹³æ»‘ç§»åŠ¨
            shieldMesh.rotation.z += 0.02;
            shieldMesh.rotation.y += 0.02;
            shieldMesh.visible = true;
        } else {
            shieldMesh.visible = false;
        }
    }

    // 2. é›·ç”µé€»è¾‘ (Lightning)
    function castLightning(fingerTip) {
        // åˆ›å»ºä¸€ä¸ªéšæœºæŠ˜çº¿
        const start = screenToWorld(fingerTip.x, fingerTip.y, -2);
        const end = new THREE.Vector3(start.x + (Math.random()-0.5)*20, start.y + (Math.random()-0.5)*20, -50);
        
        const points = [];
        let curr = start.clone();
        const segments = 10;
        for(let i=0; i<=segments; i++) {
            points.push(curr.clone());
            // å‘ç›®æ ‡æ–¹å‘ç§»åŠ¨ï¼Œç¨å¾®åŠ ç‚¹æŠ–åŠ¨
            curr.lerp(end, 1/segments);
            curr.x += (Math.random()-0.5) * 2;
            curr.y += (Math.random()-0.5) * 2;
        }
        
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geo, lightningMat);
        scene.add(line);
        lightningBolts.push({ mesh: line, life: 5 }); // å­˜æ´» 5 å¸§
    }

    // 3. é»‘æ´å¼•åŠ› (Gravity)
    function applyGravity(handPos) {
        const center = screenToWorld(handPos.x, handPos.y, 0);
        // è®©æ‰€æœ‰ç²’å­å‘æ‰‹å¿ƒç§»åŠ¨
        particles.forEach(p => {
            const dir = new THREE.Vector3().subVectors(center, p.mesh.position).normalize();
            p.vel.add(dir.multiplyScalar(0.5)); // åŠ é€Ÿå¸å…¥
        });
        
        // è§†è§‰åé¦ˆï¼šæ‰‹å¿ƒå†’é»‘çƒŸ
        if(Math.random() > 0.5) spawnParticle(handPos.x, handPos.y, 0x800080, true);
    }

    // 4. æ™®é€šç²’å­ç”Ÿæˆ
    function spawnParticle(x, y, color, isImploding=false) {
        const geo = new THREE.PlaneGeometry(0.5, 0.5);
        const mat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, mat);
        
        mesh.position.copy(screenToWorld(x, y, 0));
        // éšæœºæœå‘
        mesh.lookAt(camera.position);
        
        const vel = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, 0);
        if(!isImploding) scene.add(mesh);
        particles.push({ mesh: mesh, vel: vel, life: 60 });
        if(isImploding) scene.add(mesh);
    }

    // --- MediaPipe åˆå§‹åŒ– ---
    async function setupAI() {
        try {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            logInfo("AI æ¨¡å‹åŠ è½½å®Œæ¯•ï¼Œæ­£åœ¨å¼€å¯æ‘„åƒå¤´...");
            startCamera();
        } catch (e) {
            logError("AI åˆå§‹åŒ–å¤±è´¥: " + e.message + " | è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥");
        }
    }

    function startCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            logError("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ï¼Œæˆ–æœªåœ¨ HTTPS/Localhost ä¸‹è¿è¡Œã€‚");
            return;
        }
        
        navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } })
            .then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    logInfo(""); // æ¸…ç©ºçŠ¶æ€
                    document.getElementById('status').classList.remove('loading');
                    document.getElementById('status').style.color = "#00ff00";
                    document.getElementById('status').innerText = "LINK START >>";
                    document.getElementById('instructions').style.display = "block";
                    predictWebcam();
                });
            })
            .catch(err => {
                logError("æ‘„åƒå¤´å¼€å¯å¤±è´¥: " + err.message);
            });
    }

    // è¾…åŠ©ï¼šåˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ (Tip åˆ° Wrist çš„è·ç¦» vs Pip åˆ° Wrist çš„è·ç¦»)
    function isFingerExtended(landmarks, fingerTipIdx, fingerPipIdx) {
        const wrist = landmarks[0];
        const tip = landmarks[fingerTipIdx];
        const pip = landmarks[fingerPipIdx];
        const distTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
        const distPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
        return distTip > distPip;
    }

    // --- æ ¸å¿ƒå¾ªç¯ ---
    async function predictWebcam() {
        let startTimeMs = performance.now();
        if (lastVideoTime !== video.currentTime) {
            lastVideoTime = video.currentTime;
            if(handLandmarker) {
                results = handLandmarker.detectForVideo(video, startTimeMs);
            }
        }

        // é€»è¾‘å¤„ç†
        let shieldActive = false;
        let handCenter = {x:0.5, y:0.5};

        if (results && results.landmarks) {
            for (const landmarks of results.landmarks) {
                // è·å–æ‰‹æŒ‡çŠ¶æ€
                const idxOpen = isFingerExtended(landmarks, 8, 5);  // é£ŸæŒ‡
                const midOpen = isFingerExtended(landmarks, 12, 9); // ä¸­æŒ‡
                const ringOpen = isFingerExtended(landmarks, 16, 13);// æ— åæŒ‡
                const pinkyOpen = isFingerExtended(landmarks, 20, 17);// å°æŒ‡
                const thumbOpen = isFingerExtended(landmarks, 4, 2);  // æ‹‡æŒ‡

                // è®¡ç®—æ‰‹æŒä¸­å¿ƒ (ç”¨ 0 å’Œ 9 çš„ä¸­é—´)
                const palmX = (landmarks[0].x + landmarks[9].x) / 2;
                const palmY = (landmarks[0].y + landmarks[9].y) / 2;
                
                // 1. ğŸ¤˜ æ‘‡æ»šæ‰‹åŠ¿ (é›·ç”µ): é£ŸæŒ‡+å°æŒ‡ä¼¸ç›´ï¼Œä¸­æŒ‡+æ— åæŒ‡å¼¯æ›²
                if (idxOpen && pinkyOpen && !midOpen && !ringOpen) {
                    castLightning(landmarks[8]); // é£ŸæŒ‡å‘å°„
                    castLightning(landmarks[20]); // å°æŒ‡å‘å°„
                }
                
                // 2. ğŸ–ï¸ å¼ å¼€æ‰‹æŒ (æŠ¤ç›¾): æ‰€æœ‰æ‰‹æŒ‡éƒ½ä¼¸ç›´
                else if (idxOpen && midOpen && ringOpen && pinkyOpen) {
                    shieldActive = true;
                    handCenter = {x: palmX, y: palmY};
                }

                // 3. âœŠ æ¡æ‹³ (é»‘æ´): æ‰€æœ‰æ‰‹æŒ‡å¼¯æ›²
                else if (!idxOpen && !midOpen && !ringOpen && !pinkyOpen) {
                    applyGravity({x: palmX, y: palmY});
                }

                // 4. â˜ï¸ é»˜è®¤: åªæ˜¯é£ŸæŒ‡ä¼¸ç›´ (ç”»è½¨è¿¹)
                else if (idxOpen && !midOpen) {
                    const tip = landmarks[8];
                    spawnParticle(tip.x, tip.y, 0xffaa00); // ç•™ä¸‹ç«ç„°ç²’å­
                }
            }
        }

        // æ¸²æŸ“æ›´æ–°
        updateShield(handCenter, shieldActive);
        
        // æ›´æ–°é›·ç”µ (ä¸€é—ªè€Œè¿‡)
        for(let i = lightningBolts.length-1; i>=0; i--) {
            lightningBolts[i].life--;
            if(lightningBolts[i].life <= 0) {
                scene.remove(lightningBolts[i].mesh);
                lightningBolts.splice(i, 1);
            }
        }

        // æ›´æ–°ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life--;
            p.mesh.position.add(p.vel);
            p.mesh.rotation.z += 0.1;
            p.mesh.material.opacity = p.life / 60;
            
            if (p.life <= 0) {
                scene.remove(p.mesh);
                particles.splice(i, 1);
            }
        }

        renderer.render(scene, camera);
        window.requestAnimationFrame(predictWebcam);
    }

    // å¯åŠ¨
    setupAI();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
