<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è™šç©ºå¥¥æœ¯ï¼šå›½å†…ä¼˜åŒ–ç‰ˆ</title>
    <style>
        /* å¼ºåˆ¶èƒŒæ™¯å…¨é»‘ï¼Œé˜²æ­¢ç™½å± */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background-color: #000000 !important; 
            overflow: hidden; 
            font-family: 'Courier New', monospace; 
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI å±‚ï¼šå§‹ç»ˆç½®é¡¶ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 999;
            color: rgba(255, 255, 255, 0.9); 
            text-shadow: 0 0 5px #000;
            pointer-events: none;
            width: 300px;
        }
        
        /* åŠ è½½çŠ¶æ€æ¡ */
        #loading-bar-container {
            width: 100%; height: 4px; background: #333; margin-top: 10px;
            display: none;
        }
        #loading-bar { width: 0%; height: 100%; background: #00ffff; transition: width 0.3s; }

        .guide-box {
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            border-left: 3px solid #00ffff;
            border-radius: 4px;
            margin-top: 10px;
            display: none; /* é»˜è®¤éšè—ï¼ŒåŠ è½½å®Œæ˜¾ç¤º */
        }
        
        /* é”™è¯¯æç¤ºæ¡† */
        #error-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(50, 0, 0, 0.9); border: 2px solid red; color: white;
            padding: 20px; text-align: center; z-index: 1000; display: none;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>VOID ARCANA <span style="font-size:0.5em; color:#0ff">CN</span></h1>
    <div id="status" style="color: #ffaa00;">æ­£åœ¨åˆå§‹åŒ–...</div>
    <div id="loading-bar-container"><div id="loading-bar"></div></div>
    
    <div id="instructions" class="guide-box">
        <p style="color:#0ff; font-weight:bold;">ç³»ç»Ÿå°±ç»ª (System Ready)</p>
        <p>ğŸ–ï¸ <b>å¼ å¼€æ‰‹æŒ</b>: å…‰æ£±æŠ¤ç›¾</p>
        <p>ğŸ¤˜ <b>æ‘‡æ»šæ‰‹åŠ¿</b>: é›·éœ†é”é“¾</p>
        <p>âœŠ <b>ç”¨åŠ›æ¡æ‹³</b>: é»‘æ´å¼•åŠ›</p>
    </div>
</div>

<div id="error-box">
    <h3 id="error-title">è¿æ¥å¤±è´¥</h3>
    <p id="error-msg">è¯·æ£€æŸ¥ç½‘ç»œ</p>
    <button onclick="location.reload()" style="margin-top:10px; padding:5px 10px;">é‡è¯•</button>
</div>

<video id="videoElement" playsinline style="display:none"></video>
<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm';

    // --- æ—¥å¿—ä¸é”™è¯¯å¤„ç† ---
    const statusDiv = document.getElementById('status');
    const loadingBar = document.getElementById('loading-bar');
    const loadingContainer = document.getElementById('loading-bar-container');
    
    function showStatus(msg, progress = -1) {
        statusDiv.innerText = msg;
        console.log(`[Status] ${msg}`);
        if(progress >= 0) {
            loadingContainer.style.display = 'block';
            loadingBar.style.width = `${progress}%`;
        }
    }

    function showError(title, msg) {
        document.getElementById('error-box').style.display = 'block';
        document.getElementById('error-title').innerText = title;
        document.getElementById('error-msg').innerHTML = msg;
        statusDiv.innerText = "ç³»ç»Ÿé”™è¯¯";
        statusDiv.style.color = "red";
    }

    // --- å¼ºåˆ¶ä¿®æ­£æ ·å¼ ---
    document.body.style.backgroundColor = "black";

    // --- 1. Three.js åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.003); 
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 20;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404040, 3); 
    scene.add(ambientLight);

    // --- 2. é­”æ³•ç‰¹æ•ˆ (ç²’å­ç³»ç»Ÿ) ---
    const particles = []; 
    const lightningBolts = [];
    let shieldMesh = null;
    const shieldMat = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, emissive: 0x002255, transparent: true, opacity: 0.2, wireframe: true 
    });
    const lightningMat = new THREE.LineBasicMaterial({ color: 0xaa00ff, linewidth: 2 });

    function screenToWorld(x, y, z = 10) {
        const vec = new THREE.Vector3(((1-x) * 2) - 1, -(y * 2) + 1, 0.5); 
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        return camera.position.clone().add(vec.multiplyScalar(-camera.position.z / vec.z + z));
    }

    // æŠ¤ç›¾
    function updateShield(active, x, y) {
        if (!shieldMesh) {
            shieldMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(4, 1), shieldMat);
            scene.add(shieldMesh);
        }
        shieldMesh.visible = active;
        if (active) {
            const pos = screenToWorld(x, y, -5);
            shieldMesh.position.lerp(pos, 0.1);
            shieldMesh.rotation.y += 0.05;
        }
    }

    // é›·ç”µ
    function castLightning(x, y) {
        if(Math.random() > 0.3) return; // é™åˆ¶é¢‘ç‡
        const start = screenToWorld(x, y, -2);
        const end = new THREE.Vector3(start.x + (Math.random()-0.5)*15, start.y + (Math.random()-0.5)*15, -40);
        const points = [];
        let curr = start.clone();
        for(let i=0; i<=6; i++) {
            points.push(curr.clone());
            curr.lerp(end, 1/6).add(new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, 0));
        }
        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), lightningMat);
        scene.add(line);
        lightningBolts.push({ mesh: line, life: 4 });
    }

    // é»‘æ´ç²’å­
    function spawnParticle(x, y, color) {
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.4), new THREE.MeshBasicMaterial({ color: color }));
        mesh.position.copy(screenToWorld(x, y, 0));
        mesh.lookAt(camera.position);
        scene.add(mesh);
        particles.push({ mesh: mesh, vel: new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), 0), life: 40 });
    }

    // --- 3. AI åˆå§‹åŒ– (å…³é”®ä¿®æ”¹) ---
    let handLandmarker = undefined;
    const video = document.getElementById('videoElement');

    async function setupAI() {
        showStatus("æ­£åœ¨ä¸‹è½½ AI æ¨¡å‹ (çº¦10MB)...", 10);
        
        try {
            // Step 1: åŠ è½½ WASM
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
            );
            showStatus("å¼•æ“åŠ è½½å®Œæ¯•ï¼Œè·å–æ¨¡å‹...", 50);

            // Step 2: åŠ è½½æ¨¡å‹ (å°è¯•ä½¿ç”¨ jsDelivr é•œåƒï¼Œå¦‚æœå¤±è´¥åˆ™æŠ¥é”™)
            // è¿™æ˜¯ä¸€ä¸ªå¯ä»¥ç›´æ¥è®¿é—®çš„ CDN åœ°å€
            const modelUrl = "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task";
            
            // æ£€æµ‹ç½‘ç»œï¼šå¦‚æœæ˜¯å›½å†…ç¯å¢ƒï¼ŒGoogle é“¾æ¥å¯èƒ½ä¼šå¡æ­»
            // ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬è®¾ç½®ä¸€ä¸ªè¶…æ—¶æç¤º
            const loadTimeout = setTimeout(() => {
                showError("ä¸‹è½½è¶…æ—¶", "AI æ¨¡å‹ä¸‹è½½å¤ªæ…¢ã€‚<br><b>å¦‚æœä½ åœ¨ä¸­å›½ï¼Œè¯·å¼€å¯ VPN (ä»£ç†)ã€‚</b><br>æˆ–è€…æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚");
            }, 15000); // 15ç§’è¶…æ—¶

            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: modelUrl,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            
            clearTimeout(loadTimeout); // åŠ è½½æˆåŠŸï¼Œæ¸…é™¤è¶…æ—¶è­¦å‘Š
            showStatus("è¯·æ±‚æ‘„åƒå¤´æƒé™...", 90);
            startCamera();

        } catch (e) {
            showError("å¯åŠ¨å¤±è´¥", `è¯¦ç»†é”™è¯¯: ${e.message}<br><br>å¸¸è§åŸå› ï¼š<br>1. ç½‘ç»œæ— æ³•è®¿é—® Google<br>2. æ²¡ç»™æ‘„åƒå¤´æƒé™`);
        }
    }

    function startCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showError("æµè§ˆå™¨ä¸å…¼å®¹", "è¯·ä½¿ç”¨ Chrome / Edge / Safariã€‚<br>å¿…é¡»ä½¿ç”¨ HTTPS æˆ– localhostã€‚");
            return;
        }
        navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } })
            .then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    showStatus("ç³»ç»Ÿä¸Šçº¿", 100);
                    setTimeout(() => { 
                        loadingContainer.style.display = 'none'; 
                        document.getElementById('instructions').style.display = 'block';
                    }, 500);
                    predictWebcam();
                });
            })
            .catch(err => showError("æ‘„åƒå¤´è¢«æ‹’ç»", "è¯·å…è®¸æµè§ˆå™¨è®¿é—®æ‘„åƒå¤´ï¼Œå¹¶åˆ·æ–°é¡µé¢ã€‚"));
    }

    // --- 4. å¾ªç¯é€»è¾‘ ---
    let lastVideoTime = -1;
    function predictWebcam() {
        let startTimeMs = performance.now();
        if (lastVideoTime !== video.currentTime && handLandmarker) {
            lastVideoTime = video.currentTime;
            const results = handLandmarker.detectForVideo(video, startTimeMs);
            
            let shieldActive = false;
            let handPos = {x:0, y:0};

            if (results.landmarks) {
                for (const landmarks of results.landmarks) {
                    const idxOpen = isFingerExtended(landmarks, 8, 5);
                    const pinkyOpen = isFingerExtended(landmarks, 20, 17);
                    const midOpen = isFingerExtended(landmarks, 12, 9);
                    const ringOpen = isFingerExtended(landmarks, 16, 13);
                    const palmX = landmarks[9].x; const palmY = landmarks[9].y;

                    // é€»è¾‘åˆ¤æ–­
                    if (idxOpen && pinkyOpen && !midOpen && !ringOpen) { // æ‘‡æ»š
                        castLightning(landmarks[8].x, landmarks[8].y);
                        castLightning(landmarks[20].x, landmarks[20].y);
                    } else if (idxOpen && midOpen && ringOpen && pinkyOpen) { // å¼ å¼€
                        shieldActive = true; handPos = {x: palmX, y: palmY};
                    } else if (!idxOpen && !midOpen && !ringOpen && !pinkyOpen) { // æ¡æ‹³
                        spawnParticle(palmX, palmY, 0x8a2be2); // é»‘æ´ç²’å­
                    } else if (idxOpen) {
                        spawnParticle(landmarks[8].x, landmarks[8].y, 0xffaa00); // è½¨è¿¹
                    }
                }
            }
            updateShield(shieldActive, handPos.x, handPos.y);
        }

        // æ¸²æŸ“å¾ªç¯
        lightningBolts.forEach((b, i) => { 
            b.life--; if(b.life<=0) { scene.remove(b.mesh); lightningBolts.splice(i,1); } 
        });
        particles.forEach((p, i) => {
            p.life--; p.mesh.position.add(p.vel); p.mesh.rotation.z += 0.2; p.mesh.material.opacity = p.life/40;
            if(p.life<=0) { scene.remove(p.mesh); particles.splice(i,1); }
        });

        renderer.render(scene, camera);
        requestAnimationFrame(predictWebcam);
    }

    function isFingerExtended(lm, tip, pip) {
        return Math.hypot(lm[tip].x-lm[0].x, lm[tip].y-lm[0].y) > Math.hypot(lm[pip].x-lm[0].x, lm[pip].y-lm[0].y);
    }

    // å¯åŠ¨
    setupAI();
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
