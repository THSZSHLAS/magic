<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è™šç©ºå¥¥æœ¯ï¼šWebç‰ˆ (Void Arcana Web)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #videoElement { position: absolute; top: 0; left: 0; transform: scaleX(-1); opacity: 0; pointer-events: none; } /* éšè—åŸè§†é¢‘ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: rgba(255, 255, 255, 0.8); text-shadow: 0 0 5px #000;
            pointer-events: none;
        }
        .loading { color: #0ff; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 600px) { h1 { font-size: 1.2rem; } }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>VOID ARCANA <span style="font-size:0.5em">WEB EDITION</span></h1>
    <div id="status" class="loading">æ­£åœ¨åˆå§‹åŒ–ç¥ç»è¿æ¥... (Loading AI Models)</div>
    <div id="instructions" style="display:none; margin-top: 10px;">
        <p>ğŸ–ï¸ <b>å¼ å¼€æ‰‹æŒ</b>: å¯’å†°æŠ¤ç›¾ (Ice Shield)</p>
        <p>ğŸ‘Œ <b>æåˆOKæ‰‹åŠ¿</b>: è™šç©ºå¥‡ç‚¹ (Void Singularity)</p>
        <p>â˜ï¸ <b>é£ŸæŒ‡ç”»åœˆ/ä¸‰è§’</b>: çƒˆç„°è½¨è¿¹ (Fire Trail)</p>
    </div>
</div>

<video id="videoElement" playsinline></video>
<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

    // --- å…¨å±€å˜é‡ ---
    const video = document.getElementById('videoElement');
    const statusDiv = document.getElementById('status');
    const instrDiv = document.getElementById('instructions');
    let handLandmarker = undefined;
    let lastVideoTime = -1;
    let results = undefined;

    // --- 1. Three.js åœºæ™¯åˆå§‹åŒ– (The World) ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002); // è™šç©ºè¿·é›¾

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 20;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(0, 10, 10);
    scene.add(pointLight);

    // --- 2. é­”æ³•ç‰¹æ•ˆç³»ç»Ÿ (Magic System) ---
    const spells = []; // å­˜å‚¨å‘å°„å‡ºå»çš„é­”æ³•
    const particles = []; // å­˜å‚¨ç²’å­
    const trailPoints = []; // å­˜å‚¨é£ŸæŒ‡è½¨è¿¹
    let trailMesh = null;

    // æè´¨ç¼“å­˜
    const fireMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });
    const iceMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x00ffff, emissive: 0x001133, roughness: 0.1, metalness: 0.8, transparent: true, opacity: 0.7 
    });
    const voidMaterial = new THREE.PointsMaterial({ color: 0x8a2be2, size: 0.5, sizeAttenuation: true });

    // è¾…åŠ©å‡½æ•°ï¼šå±å¹•åæ ‡è½¬3Dä¸–ç•Œåæ ‡
    function screenToWorld(x, y, z = 10) {
        const vec = new THREE.Vector3();
        vec.set((x * 2) - 1, -(y * 2) + 1, 0.5);
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        const distance = -camera.position.z / vec.z + z; // z is depth offset
        return camera.position.clone().add(vec.multiplyScalar(distance));
    }

    // ç‰¹æ•ˆï¼šç«ç„°è½¨è¿¹
    function updateTrail(x, y) {
        const pos = screenToWorld(x, y, 0); // é è¿‘å±å¹•
        trailPoints.push(pos);
        if (trailPoints.length > 20) trailPoints.shift(); // é™åˆ¶é•¿åº¦

        if (trailMesh) scene.remove(trailMesh);
        if (trailPoints.length > 1) {
            const geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            // ç®€å•çš„çº¿æ®µï¼Œè¿›é˜¶å¯ä»¥ç”¨ TubeGeometry
            const material = new THREE.LineBasicMaterial({ color: 0xffaa00, linewidth: 2 });
            trailMesh = new THREE.Line(geometry, material);
            scene.add(trailMesh);
        }
    }

    // ç‰¹æ•ˆï¼šè™šç©ºå……èƒ½ (OKæ‰‹åŠ¿)
    function spawnVoidParticles(x, y) {
        const center = screenToWorld(x, y, 0);
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        for(let i=0; i<5; i++) {
            // éšæœºæŠ–åŠ¨
            vertices.push(center.x + (Math.random()-0.5), center.y + (Math.random()-0.5), center.z);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        const pts = new THREE.Points(geometry, voidMaterial);
        scene.add(pts);
        particles.push({ mesh: pts, life: 30, type: 'void' });
    }

    // ç‰¹æ•ˆï¼šå‘å°„å†°é”¥ (å¼ å¼€æ‰‹æŒ)
    let cooldown = 0;
    function castIceShard(x, y) {
        if (cooldown > 0) return;
        cooldown = 20; // å†·å´æ—¶é—´

        const geometry = new THREE.ConeGeometry(0.5, 3, 4);
        const mesh = new THREE.Mesh(geometry, iceMaterial);
        const startPos = screenToWorld(x, y, -5);
        mesh.position.copy(startPos);
        
        // æŒ‡å‘å±å¹•æ·±å¤„
        mesh.rotation.x = -Math.PI / 2;
        mesh.rotation.z = Math.random() * Math.PI;

        scene.add(mesh);
        spells.push({ mesh: mesh, vel: new THREE.Vector3(0, 0, -0.8), type: 'ice' });
    }

    // --- 3. MediaPipe åˆå§‹åŒ– (AI Brain) ---
    async function setupAI() {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 2
        });
        statusDiv.innerText = "System Ready. Waiting for Camera...";
        startCamera();
    }

    // --- 4. æ‘„åƒå¤´æ§åˆ¶ ---
    function startCamera() {
        navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } })
            .then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
                statusDiv.innerText = "Active";
                statusDiv.classList.remove('loading');
                statusDiv.style.color = "#0f0";
                instrDiv.style.display = "block";
            });
    }

    // --- 5. æ ¸å¿ƒé€»è¾‘å¾ªç¯ (Loop) ---
    async function predictWebcam() {
        // 1. AI è¯†åˆ«
        let startTimeMs = performance.now();
        if (lastVideoTime !== video.currentTime) {
            lastVideoTime = video.currentTime;
            results = handLandmarker.detectForVideo(video, startTimeMs);
        }

        // 2. é€»è¾‘åˆ¤å®š
        if (results && results.landmarks) {
            // æ²¡æœ‰æ‰‹çš„æ—¶å€™æ¸…ç©ºè½¨è¿¹
            if (results.landmarks.length === 0) {
                trailPoints.length = 0;
                if(trailMesh) { scene.remove(trailMesh); trailMesh = null; }
            }

            for (const landmarks of results.landmarks) {
                // MediaPipe åæ ‡æ˜¯ 0.0 - 1.0
                // 8: é£ŸæŒ‡æŒ‡å°–, 4: æ‹‡æŒ‡æŒ‡å°–, 0: æ‰‹è…•, 12: ä¸­æŒ‡æŒ‡å°–
                const idx = landmarks[8];
                const thumb = landmarks[4];
                const mid = landmarks[12];
                
                // è®¡ç®—è·ç¦» (ç®€å•çš„æ‰‹åŠ¿åˆ¤æ–­)
                const pinchDist = Math.hypot(idx.x - thumb.x, idx.y - thumb.y);
                const openHandDist = Math.hypot(idx.x - 0, idx.y - 0); // å¹¶ä¸æ˜¯å¾ˆå‡†ï¼Œä½†è¶³å¤Ÿç®€å•

                // æ‰‹åŠ¿ A: OK æ‰‹åŠ¿ (Pinch) -> è™šç©º
                if (pinchDist < 0.05) {
                    spawnVoidParticles(idx.x, idx.y); // æ³¨æ„ï¼šMediaPipe x æ˜¯é•œåƒçš„
                } 
                // æ‰‹åŠ¿ B: å¼ å¼€æ‰‹æŒ (ç®€å•çš„åˆ¤æ–­ï¼šé£ŸæŒ‡å’Œæ‹‡æŒ‡å¾ˆè¿œ) -> å†°é”¥
                else if (pinchDist > 0.15) {
                    castIceShard(mid.x, mid.y); // ç”¨ä¸­æŒ‡å‘å°„
                    updateTrail(idx.x, idx.y); // åŒæ—¶ä¿ç•™ä¸€ç‚¹è½¨è¿¹
                }
                // é»˜è®¤ï¼šç»˜åˆ¶è½¨è¿¹
                else {
                    updateTrail(idx.x, idx.y);
                }
            }
        }

        // 3. æ¸²æŸ“ç”»é¢
        renderLoop();
        
        window.requestAnimationFrame(predictWebcam);
    }

    function renderLoop() {
        if(cooldown > 0) cooldown--;

        // æ›´æ–°é­”æ³•ç‰©ä½“
        for (let i = spells.length - 1; i >= 0; i--) {
            const s = spells[i];
            s.mesh.position.add(s.vel);
            s.mesh.rotation.z += 0.1;
            
            if (s.mesh.position.z < -50) { // é£è¿œäº†æ¶ˆå¤±
                scene.remove(s.mesh);
                spells.splice(i, 1);
            }
        }

        // æ›´æ–°ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life--;
            p.mesh.material.opacity = p.life / 30;
            // ç®€å•çš„æ‰©æ•£åŠ¨ç”»
            const positions = p.mesh.geometry.attributes.position.array;
            for(let j=0; j<positions.length; j+=3) {
                positions[j] += (Math.random()-0.5) * 0.1;
                positions[j+1] += (Math.random()-0.5) * 0.1;
            }
            p.mesh.geometry.attributes.position.needsUpdate = true;

            if (p.life <= 0) {
                scene.remove(p.mesh);
                particles.splice(i, 1);
            }
        }

        renderer.render(scene, camera);
    }

    // å¯åŠ¨
    setupAI();

    // çª—å£è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
