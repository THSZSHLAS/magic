<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Master V10: Barrage</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* è§†é¢‘å±‚ï¼šé•œåƒç¿»è½¬ï¼Œé€æ˜ */
        #videoElement { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; opacity: 0; z-index: -1; pointer-events: none; transform: scaleX(-1); 
        }
        
        /* UI å±‚ */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; 
            pointer-events: none; 
        }
        
        /* å¯åŠ¨æŒ‰é’® */
        #start-btn {
            pointer-events: auto; padding: 20px 60px; font-size: 30px; font-weight: 900; letter-spacing: 4px;
            color: #fff; background: rgba(0,0,0,0.6); 
            border: 3px solid #00ffff; border-radius: 4px; cursor: pointer;
            box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
            text-shadow: 0 0 10px #fff; transition: 0.2s;
        }
        #start-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 50px #00ffff; }

        /* HUD çŠ¶æ€æ  */
        #hud { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); 
            z-index: 100; text-align: center; pointer-events: none; display: none;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8), transparent);
            padding: 10px 50px; width: 80%;
        }
        #spell-name {
            font-size: 36px; font-weight: bold; letter-spacing: 5px; text-transform: uppercase;
            text-shadow: 0 0 20px currentColor; transition: color 0.2s;
        }
        #combo-counter { font-size: 14px; color: #888; margin-top: 5px; }

        /* å‡†æ˜Ÿ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 60px; height: 60px;
            transform: translate(-50%, -50%); 
            border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; 
            pointer-events: none; z-index: 50; transition: transform 0.1s;
        }
        #crosshair.shooting { transform: translate(-50%, -50%) scale(0.8); border-color: #00ffff; }
        
        /* è“„åŠ›æ¡ */
        #charge-bar {
            position: absolute; top: 55%; left: 50%; transform: translateX(-50%);
            width: 0px; height: 4px; background: #ff4500; 
            box-shadow: 0 0 10px #ff4500; transition: width 0.1s;
        }
    </style>
</head>
<body>

<div id="hud">
    <div id="spell-name" style="color: #444;">SYSTEM READY</div>
    <div id="combo-counter">PROJECTILES: <span id="proj-count">0</span></div>
</div>
<div id="charge-bar"></div>
<div id="crosshair"></div>

<div id="ui-layer">
    <h1 style="color:white; text-shadow: 0 0 30px #00ffff; margin-bottom: 40px; font-style:italic;">MAGIC V10</h1>
    <button id="start-btn" onclick="startApp()">ENGAGE</button>
</div>

<video id="videoElement" playsinline muted autoplay></video>
<div id="canvas-container"></div>

<script type="importmap">
    { "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
    }}
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- å…¨å±€å˜é‡ ---
    let camera, scene, renderer, composer;
    let handLandmarker, video;
    let isRunning = false;
    let lastTime = 0;
    
    // --- æ¸¸æˆçŠ¶æ€ç®¡ç† ---
    const GameState = {
        projectiles: [],
        particles: [],
        lightnings: [],
        beam: null,
        charging: { active: false, power: 0, mesh: null },
        cooldown: 0
    };

    // --- 1. å›¾å½¢å¼•æ“åˆå§‹åŒ– (Graphics) ---
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.004); // è™šç©ºè¿·é›¾

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // æ€§èƒ½ä¼˜åŒ–
        container.appendChild(renderer.domElement);

        // åå¤„ç† (Bloom è¾‰å…‰)
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 2.0; 
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.1;

        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        initAssets();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // --- 2. èµ„æºåˆå§‹åŒ– (Assets) ---
    function initAssets() {
        // è“„åŠ›çƒ
        const chargeGeo = new THREE.SphereGeometry(1, 32, 32);
        const chargeMat = new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.8 });
        GameState.charging.mesh = new THREE.Mesh(chargeGeo, chargeMat);
        GameState.charging.mesh.visible = false;
        scene.add(GameState.charging.mesh);

        // æ¿€å…‰æŸ (V8å¤ç”¨)
        const beamGeo = new THREE.CylinderGeometry(0.3, 1.0, 50, 8);
        beamGeo.rotateX(-Math.PI / 2);
        beamGeo.translate(0, 0, -25); // Pivot fix
        const beamMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
        GameState.beam = new THREE.Mesh(beamGeo, beamMat);
        GameState.beam.visible = false;
        scene.add(GameState.beam);
    }

    // --- 3. ç²’å­ä¸ç‰¹æ•ˆç³»ç»Ÿ (VFX System) ---
    
    // ç”Ÿæˆå…‰æ™•è´´å›¾
    function getGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        return new THREE.CanvasTexture(canvas);
    }
    const particleTex = getGlowTexture();

    // å‘å°„æŠ•å°„ç‰©
    function shootProjectile(pos, type) {
        let color, size, speed, life;
        
        if (type === 'missile') { // ğŸ– å¼ æ‰‹é€Ÿå°„
            color = 0x00ffff; // é’è‰²
            size = 0.6;
            speed = 2.5;
            life = 60;
        } else if (type === 'nuke') { // ğŸ‘Œ è“„åŠ›æ ¸å¼¹
            color = 0xff4500; // æ©™çº¢è‰²
            size = 3.0 + (GameState.charging.power / 10);
            speed = 1.2;
            life = 100;
        }

        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
            map: particleTex, color: color, blending: THREE.AdditiveBlending 
        }));
        sprite.position.copy(pos);
        sprite.scale.set(size, size, 1);

        // ç›®æ ‡ï¼šå±å¹•æ­£ä¸­å¿ƒæ·±å¤„ï¼Œç¨å¾®å¸¦ä¸€ç‚¹éšæœºæ•£å°„
        const target = new THREE.Vector3(
            (Math.random()-0.5)*5, 
            (Math.random()-0.5)*5, 
            -100
        );
        const velocity = new THREE.Vector3().subVectors(target, pos).normalize().multiplyScalar(speed);

        scene.add(sprite);
        GameState.projectiles.push({ mesh: sprite, vel: velocity, type: type, life: life });
        
        // è§†è§‰åé¦ˆ
        document.getElementById('crosshair').classList.add('shooting');
        setTimeout(() => document.getElementById('crosshair').classList.remove('shooting'), 50);
    }

    // é—ªç”µé“¾
    function castLightning(start) {
        const points = [];
        let curr = start.clone();
        const end = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, -30);
        
        for(let i=0; i<8; i++) {
            points.push(curr.clone());
            curr.lerp(end, 0.2).add(new THREE.Vector3((Math.random()-0.5)*4, (Math.random()-0.5)*4, 0));
        }
        const line = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(points), 
            new THREE.LineBasicMaterial({ color: 0xaa00ff, linewidth: 2 })
        );
        scene.add(line);
        GameState.lightnings.push({ mesh: line, life: 3 });
    }

    // é»‘æ´å¸é™„
    function applyBlackHole(center) {
        // å¸é™„æ‰€æœ‰çš„æŠ•å°„ç‰©å’Œç²’å­
        const gravity = 0.8;
        GameState.projectiles.forEach(p => {
            const dir = new THREE.Vector3().subVectors(center, p.mesh.position).normalize();
            p.vel.add(dir.multiplyScalar(gravity)); // ä¿®æ”¹é€Ÿåº¦å‘é‡
            p.mesh.scale.multiplyScalar(0.95); // å‹ç¼©
        });
        
        // ç”Ÿæˆç´«è‰²å¸å…¥ç²’å­
        if(Math.random()>0.5) {
            const p = new THREE.Sprite(new THREE.SpriteMaterial({map:particleTex, color:0x8a2be2, blending:THREE.AdditiveBlending}));
            p.position.copy(center).add(new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10));
            p.scale.set(0.5,0.5,1);
            scene.add(p);
            GameState.particles.push({mesh:p, vel:new THREE.Vector3().subVectors(center, p.position).multiplyScalar(0.1), life:20});
        }
    }

    // --- 4. é€»è¾‘ä¸»å¾ªç¯ (Main Logic) ---
    function updateLogic(landmarks) {
        const lm = landmarks;
        // åæ ‡è½¬æ¢
        const palm = screenToWorld(lm[9].x, lm[9].y, 0);
        const idxTip = screenToWorld(lm[8].x, lm[8].y, 0);

        // æ‰‹æŒ‡çŠ¶æ€
        const idxUp = lm[8].y < lm[6].y;
        const midUp = lm[12].y < lm[10].y;
        const ringUp = lm[16].y < lm[14].y;
        const pinkyUp = lm[20].y < lm[18].y;
        
        // æåˆæ£€æµ‹
        const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
        const isPinching = pinchDist < 0.05;

        // UI æ–‡æœ¬æ›´æ–°
        const hudName = document.getElementById('spell-name');
        
        // --- çŠ¶æ€æœº ---
        
        // 1. ğŸ‘Œ è“„åŠ› (ä¼˜å…ˆçº§æœ€é«˜)
        if (isPinching) {
            GameState.charging.active = true;
            GameState.charging.power = Math.min(GameState.charging.power + 1, 100);
            
            // æ›´æ–°è“„åŠ›çƒ
            GameState.charging.mesh.visible = true;
            GameState.charging.mesh.position.copy(idxTip);
            const scale = 0.5 + (GameState.charging.power / 30);
            GameState.charging.mesh.scale.set(scale, scale, scale);
            // é¢œè‰²æ¸å˜ é»„->çº¢
            GameState.charging.mesh.material.color.setHSL(0.1 - (GameState.charging.power/1000), 1, 0.5);

            hudName.innerText = "CHARGING...";
            hudName.style.color = "#ffaa00";
            document.getElementById('charge-bar').style.width = GameState.charging.power + 'px';
            return; // è“„åŠ›æ—¶ä¸åšå…¶ä»–äº‹
        } 
        
        // 2. è“„åŠ›é‡Šæ”¾åˆ¤å®š (ä» Pinch å˜ä¸º Open)
        if (GameState.charging.active && !isPinching) {
            // å‘å°„æ ¸å¼¹
            if (GameState.charging.power > 10) {
                shootProjectile(idxTip, 'nuke');
            }
            // é‡ç½®
            GameState.charging.active = false;
            GameState.charging.power = 0;
            GameState.charging.mesh.visible = false;
            document.getElementById('charge-bar').style.width = '0px';
            GameState.cooldown = 10; // å‘å°„åå†·å´ä¸€ä¸‹
        }

        // å†·å´å¤„ç†
        if (GameState.cooldown > 0) {
            GameState.cooldown--;
            return;
        }

        // 3. ğŸ– å¼ æ‰‹ = è‡ªåŠ¨é€Ÿå°„ (Auto Fire)
        // æ¡ä»¶ï¼šæ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´ï¼Œä¸”æ²¡æœ‰åœ¨æåˆ
        if (idxUp && midUp && ringUp && pinkyUp) {
            hudName.innerText = "AUTO BARRAGE";
            hudName.style.color = "#00ffff";
            
            // å°„é€Ÿæ§åˆ¶: æ¯5å¸§å‘ä¸€å‘
            if (performance.now() % 100 < 20) {
                shootProjectile(palm, 'missile');
            }
        }
        
        // 4. ğŸ¤˜ æ‘‡æ»šæ‰‹ = é—ªç”µ (Lightning)
        else if (idxUp && pinkyUp && !midUp && !ringUp) {
            hudName.innerText = "THUNDER";
            hudName.style.color = "#aa00ff";
            if(Math.random() > 0.5) castLightning(idxTip);
            if(Math.random() > 0.5) castLightning(screenToWorld(lm[20].x, lm[20].y, 0));
        }

        // 5. âœŒï¸ å‰ªåˆ€æ‰‹ = æ¿€å…‰ (Beam)
        else if (idxUp && midUp && !ringUp && !pinkyUp) {
            hudName.innerText = "VOID BEAM";
            hudName.style.color = "#ff00ff";
            
            GameState.beam.visible = true;
            // æ¿€å…‰ä½ç½®åœ¨ä¸¤æŒ‡ä¸­é—´
            const mid = screenToWorld(lm[12].x, lm[12].y, 0);
            GameState.beam.position.copy(idxTip).add(mid).multiplyScalar(0.5);
            
            // äº§ç”Ÿç²’å­
            if(Math.random()>0.5) {
                const p = new THREE.Sprite(new THREE.SpriteMaterial({map:particleTex, color:0xff00ff}));
                p.position.copy(GameState.beam.position);
                p.scale.set(0.5,0.5,1);
                scene.add(p);
                GameState.particles.push({mesh:p, vel:new THREE.Vector3((Math.random()-.5),(Math.random()-.5),2), life:10});
            }
        } else {
            GameState.beam.visible = false;
        }

        // 6. âœŠ æ¡æ‹³ = é»‘æ´ (Gravity)
        if (!idxUp && !midUp && !ringUp && !pinkyUp) {
            hudName.innerText = "BLACK HOLE";
            hudName.style.color = "#444444";
            applyBlackHole(palm);
        } else if (!isPinching) {
            // æ²¡æ¡æ‹³å°±æ²¡å­—
            if(!idxUp) hudName.innerText = "READY";
        }
    }

    function animate() {
        if (!isRunning) return;
        requestAnimationFrame(animate);

        // ç‰©ç†æ›´æ–°
        // Projectiles
        for (let i = GameState.projectiles.length - 1; i >= 0; i--) {
            const p = GameState.projectiles[i];
            p.mesh.position.add(p.vel);
            p.life--;
            if (p.life <= 0 || p.mesh.position.z < -150) {
                scene.remove(p.mesh);
                GameState.projectiles.splice(i, 1);
            }
        }
        document.getElementById('proj-count').innerText = GameState.projectiles.length;

        // Lightnings
        for (let i = GameState.lightnings.length - 1; i >= 0; i--) {
            GameState.lightnings[i].life--;
            if (GameState.lightnings[i].life <= 0) {
                scene.remove(GameState.lightnings[i].mesh);
                GameState.lightnings.splice(i, 1);
            }
        }

        // Particles
        for (let i = GameState.particles.length - 1; i >= 0; i--) {
            const p = GameState.particles[i];
            p.mesh.position.add(p.vel);
            p.life--;
            p.mesh.material.opacity = p.life / 20;
            if (p.life <= 0) {
                scene.remove(p.mesh);
                GameState.particles.splice(i, 1);
            }
        }

        // AI æ›´æ–°
        const now = performance.now();
        if (handLandmarker && video.currentTime > 0) {
            const results = handLandmarker.detectForVideo(video, now);
            if (results.landmarks && results.landmarks.length > 0) {
                updateLogic(results.landmarks[0]);
            } else {
                GameState.beam.visible = false;
                GameState.charging.mesh.visible = false;
            }
        }

        composer.render();
    }

    // å·¥å…·å‡½æ•°
    function screenToWorld(x, y, z) {
        const vec = new THREE.Vector3(((1-x)*2)-1, -(y*2)+1, 0.5);
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        return camera.position.clone().add(vec.multiplyScalar(-camera.position.z/vec.z + z));
    }

    // å¯åŠ¨
    window.startApp = async function() {
        const btn = document.getElementById('start-btn');
        btn.innerText = "LOADING...";
        
        initThree();
        
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
            runningMode: "VIDEO", numHands: 1
        });
        
        video = document.getElementById('videoElement');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
        video.srcObject = stream;
        video.onloadeddata = () => {
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            isRunning = true;
            animate();
        };
    }
</script>
</body>
</html>
